// #!/usr/bin/env node

// import { readFileSync, writeFileSync, existsSync } from 'fs';
// import { resolve, basename, dirname, extname, join } from 'path';
// import { Command } from 'commander';
// import { RippleAssembler } from '../assembler.js';

// const program = new Command();

// program
//   .name('ripple-asm')
//   .description('Ripple VM Assembler - Converts RISC-like assembly to macro format')
//   .version('1.0.0')
//   .argument('<input>', 'input assembly file')
//   .option('-o, --output <file>', 'output file (default: input file with .bfm extension)')
//   .option('-b, --bank-size <size>', 'bank size (instructions per bank)', parseInt, 16)
//   .option('-m, --max-immediate <value>', 'maximum immediate value', parseInt, 65535)
//   .option('--no-case-sensitive', 'disable case-insensitive mnemonics')
//   .option('-s, --start-bank <bank>', 'starting bank number', parseInt, 0)
//   .option('-d, --data <file>', 'include data from file')
//   .option('-c, --comments', 'include comments in output', false)
//   .option('-h, --header <text>', 'add header comment to output')
//   .option('-v, --verbose', 'verbose output')
//   .option('--dry-run', 'parse and validate without writing output')
//   .option('--show-stats', 'show assembly statistics')
//   .action((inputFile, options) => {
//     try {
//       // Resolve input file path
//       const inputPath = resolve(inputFile);

//       if (!existsSync(inputPath)) {
//         console.error(`Error: Input file '${inputPath}' does not exist`);
//         process.exit(1);
//       }

//       if (options.verbose) {
//         console.log(`Reading input file: ${inputPath}`);
//       }

//       // Read input file
//       const source = readFileSync(inputPath, 'utf-8');

//       // Create assembler with options
//       const assemblerOptions = {
//         bankSize: options.bankSize,
//         maxImmediate: options.maxImmediate,
//         caseInsensitive: options.caseSensitive !== false,
//         startBank: options.startBank
//       };

//       if (options.verbose) {
//         console.log('Assembler configuration:');
//         console.log(`  Bank size: ${assemblerOptions.bankSize || 16}`);
//         console.log(`  Max immediate: ${assemblerOptions.maxImmediate || 65535}`);
//         console.log(`  Case insensitive: ${assemblerOptions.caseInsensitive !== false}`);
//         console.log(`  Start bank: ${assemblerOptions.startBank || 0}`);
//       }

//       const assembler = new RippleAssembler(assemblerOptions);

//       // Assemble the source
//       if (options.verbose) {
//         console.log('Assembling...');
//       }

//       const result = assembler.assemble(source);

//       // Check for errors
//       if (result.errors.length > 0) {
//         console.error('Assembly errors:');
//         result.errors.forEach(error => {
//           console.error(`  ${error}`);
//         });
//         process.exit(1);
//       }

//       // Show statistics if requested
//       if (options.showStats) {
//         console.log('\nAssembly statistics:');
//         console.log(`  Instructions: ${result.instructions.length}`);
//         console.log(`  Banks used: ${Math.ceil(result.instructions.length / assembler.getBankSize())}`);
//         console.log(`  Labels defined: ${result.labels.size}`);
//         if (result.labels.size > 0) {
//           console.log('  Labels:');
//           for (const [name, label] of result.labels) {
//             console.log(`    ${name}: bank ${label.bank}, offset ${label.offset}`);
//           }
//         }
//       }

//       // Load data if specified
//       let data: number[] | undefined;
//       if (options.data) {
//         const dataPath = resolve(options.data);
//         if (!existsSync(dataPath)) {
//           console.error(`Error: Data file '${dataPath}' does not exist`);
//           process.exit(1);
//         }

//         if (options.verbose) {
//           console.log(`Reading data file: ${dataPath}`);
//         }

//         const dataContent = readFileSync(dataPath);
//         data = Array.from(dataContent);
//       }

//       // Generate output
//       let output: string;

//       // Combine external data with embedded data
//       const allData = [...(result.memoryData || []), ...(data || [])];

//       if (allData.length > 0 || options.header) {
//         // Generate full format with data section and/or header
//         output = assembler.toFullMacroFormat(
//           result.instructions,
//           allData,
//           options.comments ? extractComments(source) : undefined,
//           options.header
//         );
//       } else {
//         // Generate simple format
//         output = assembler.toMacroFormat(
//           result.instructions,
//           options.comments ? extractComments(source) : undefined
//         );
//       }

//       // Handle dry run
//       if (options.dryRun) {
//         console.log('Dry run - no output written');
//         console.log(`Would write ${output.length} characters`);
//         process.exit(0);
//       }

//       // Determine output file
//       let outputPath: string;
//       if (options.output) {
//         outputPath = resolve(options.output);
//       } else {
//         // Default: replace extension with .bfm
//         const dir = dirname(inputPath);
//         const base = basename(inputPath, extname(inputPath));
//         outputPath = join(dir, base + '.bfm');
//       }

//       // Write output
//       if (options.verbose) {
//         console.log(`Writing output to: ${outputPath}`);
//       }

//       writeFileSync(outputPath, output, 'utf-8');

//       console.log(`Successfully assembled to: ${outputPath}`);
//       if (options.verbose) {
//         console.log(`Output size: ${output.length} characters`);
//       }

//     } catch (error: any) {
//       console.error(`Error: ${error.message}`);
//       process.exit(1);
//     }
//   });

// // Add examples to help
// program.on('--help', () => {
//   console.log('');
//   console.log('Examples:');
//   console.log('  $ ripple-asm program.asm');
//   console.log('  $ ripple-asm program.asm -o output.bfm');
//   console.log('  $ ripple-asm program.asm --bank-size 8 --max-immediate 255');
//   console.log('  $ ripple-asm program.asm --data hello.txt --header "Hello World Program"');
//   console.log('  $ ripple-asm program.asm --show-stats --verbose');
//   console.log('');
//   console.log('Input format:');
//   console.log('  The assembler accepts RISC-like assembly with the following features:');
//   console.log('  - Instructions: LI, ADD, SUB, JAL, BEQ, etc.');
//   console.log('  - Registers: R0-R15, PC, RA, etc.');
//   console.log('  - Labels: loop:, start:, etc.');
//   console.log('  - Comments: ; comment, # comment, // comment');
//   console.log('  - Sections: .data and .code');
//   console.log('');
//   console.log('Data section directives:');
//   console.log('  .byte / .db     - Define bytes: .byte 0x48, \'H\', 72');
//   console.log('  .word / .dw     - Define words: .word 0x1234, 1000');
//   console.log('  .string / .ascii - Define string: .string "Hello"');
//   console.log('  .asciiz         - Define null-terminated string: .asciiz "Hello"');
//   console.log('  .space / .zero  - Reserve space: .space 10');
//   console.log('');
//   console.log('Output format:');
//   console.log('  Generates macro format suitable for the Ripple VM linker:');
//   console.log('  @program_start(...), @cmd(...), @program_end');
// });

// // Helper function to extract comments from source
// function extractComments(source: string): Map<number, string> {
//   const comments = new Map<number, string>();
//   const lines = source.split('\n');
//   let instructionIndex = 0;

//   for (const line of lines) {
//     // Check if line has an instruction
//     const trimmed = line.trim();
//     if (!trimmed || trimmed.startsWith(';') || trimmed.startsWith('#') || trimmed.startsWith('//')) {
//       continue;
//     }

//     // Check for inline comment
//     const commentMatch = line.match(/[;#](.*)$/);
//     if (commentMatch) {
//       const hasInstruction = line.match(/^\s*(?:\w+:)?\s*\w+/);
//       if (hasInstruction) {
//         comments.set(instructionIndex, commentMatch[1].trim());
//         instructionIndex++;
//       }
//     } else {
//       // Check if it's a label-only line
//       if (!line.match(/^\s*\w+:\s*$/)) {
//         instructionIndex++;
//       }
//     }
//   }

//   return comments;
// }

// // Parse command line arguments
// program.parse(process.argv);

// // Show help if no arguments
// if (process.argv.length === 2) {
//   program.help();
// }
